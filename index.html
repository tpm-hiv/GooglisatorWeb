<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Googlisator Web</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            text-align: center;
        }

        .logo {
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .logo img {
            width: 100px;
            height: auto;
            border-radius: 12px;
        }

        .logo-text {
            font-size: 24px;
            font-weight: bold;
            color: #FFA500;
            margin-top: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .drop-zone {
            border: 3px dashed #0F9D58;
            border-radius: 16px;
            padding: 60px 20px;
            margin: 30px 0;
            background: linear-gradient(135deg, rgba(15, 157, 88, 0.1) 0%, rgba(15, 157, 88, 0.05) 100%);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .drop-zone::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .drop-zone:hover::before {
            left: 100%;
        }

        .drop-zone.dragover {
            border-color: #4285F4;
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.2) 0%, rgba(66, 133, 244, 0.1) 100%);
            transform: scale(1.02);
        }

        .drop-zone h3 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #0F9D58;
        }

        .drop-zone p {
            color: #cccccc;
            font-size: 14px;
        }

        .file-input {
            display: none;
        }

        .content-preview {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .title-display {
            font-size: 18px;
            font-weight: bold;
            color: #FFA500;
            margin-bottom: 15px;
            word-wrap: break-word;
        }

        .package-status {
            margin: 15px 0;
            padding: 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .status-text {
            font-size: 12px;
            font-weight: bold;
            color: #ffffff;
        }

        .package-type {
            font-size: 14px;
            font-weight: bold;
            color: #FFA500;
            margin-top: 5px;
        }

        .validation-messages {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #FFA500;
            border-radius: 8px;
            padding: 10px;
            margin: 15px 0;
            font-size: 12px;
            color: #FFA500;
        }

        /* Two-column layout container */
        .two-column-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            width: 100%;
        }

        .left-column {
            flex: 1;
            min-width: 0;
        }

        .right-column {
            flex: 1;
            min-width: 0;
        }

        /* Responsive layout for larger screens */
        @media (min-width: 1200px) {
            .two-column-container {
                gap: 30px;
            }
            
            .left-column {
                flex: 1.2;
            }
            
            .right-column {
                flex: 1.3;
            }
        }

        @media (min-width: 1400px) {
            .container {
                max-width: 1400px;
            }
            
            .two-column-container {
                gap: 40px;
            }
            
            .left-column {
                flex: 1;
            }
            
            .right-column {
                flex: 1.4;
            }
        }

        .data-preview {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
        }

        .asset-analysis {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
        }

        .preview-title {
            color: #0F9D58;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .preview-table-container {
            max-height: 400px;
            overflow-y: auto;
            border-radius: 8px;
        }

        .preview-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }

        .preview-table th {
            background: rgba(66, 133, 244, 0.8);
            color: white;
            padding: 10px 8px;
            text-align: left;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .preview-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            vertical-align: top;
        }

        .preview-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .field-name {
            font-weight: bold;
            color: #FFA500;
            width: 25%;
            min-width: 150px;
        }

        .field-value {
            width: 60%;
        }

        .field-status {
            width: 15%;
            text-align: center;
        }

        .editable-field {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            padding: 6px;
            color: white;
            width: 100%;
            font-size: 12px;
            font-family: inherit;
            resize: vertical;
            min-height: 20px;
        }

        .editable-field:focus {
            outline: none;
            border-color: #4285F4;
            background: rgba(66, 133, 244, 0.1);
        }

        .status-required {
            background: rgba(219, 68, 55, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .status-recommended {
            background: rgba(255, 165, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .status-optional {
            background: rgba(15, 157, 88, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }

        .asset-count {
            color: #0F9D58;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        .asset-list {
            max-height: 350px;
            overflow-y: auto;
        }

        .asset-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .asset-info {
            flex: 1;
            text-align: left;
            min-width: 0;
        }

        .asset-type {
            color: #4285F4;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .asset-filename {
            color: #FFA500;
            font-size: 11px;
            font-family: monospace;
            word-break: break-all;
            line-height: 1.3;
            margin-top: 2px;
        }

        .copy-btn {
            background: linear-gradient(45deg, #0F9D58, #0d8a4c);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            flex-shrink: 0;
            min-width: 60px;
        }

        .copy-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(15, 157, 88, 0.3);
        }

        .copy-btn.copied {
            background: linear-gradient(45deg, #4285F4, #3a78d9);
        }

        .filename-preview {
            margin: 20px 0;
        }

        .filename-label {
            color: #0F9D58;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .editable-filename {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid rgba(255, 165, 0, 0.5);
            border-radius: 6px;
            padding: 8px;
            color: #FFA500;
            width: 100%;
            font-size: 12px;
            font-weight: bold;
            font-family: inherit;
            text-align: center;
        }

        .editable-filename:focus {
            outline: none;
            border-color: #4285F4;
            background: rgba(66, 133, 244, 0.1);
            color: #4285F4;
        }

        .generate-btn {
            background: linear-gradient(45deg, #4285F4, #3a78d9);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .generate-btn:hover:not(:disabled) {
            background: linear-gradient(45deg, #3a78d9, #2d6cc2);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
        }

        .generate-btn:disabled {
            background: #666666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4285F4;
            animation: confetti-explode 2s ease-out forwards;
            border-radius: 2px;
        }

        .confetti:nth-child(2n) { background: #DB4437; }
        .confetti:nth-child(3n) { background: #F4B400; }
        .confetti:nth-child(4n) { background: #0F9D58; }
        .confetti:nth-child(5n) { background: #FFA500; }

        @keyframes confetti-explode {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--dx), var(--dy)) rotate(var(--rotation)) scale(0.3);
                opacity: 0;
            }
        }

        .generate-btn.celebrating {
            animation: button-pulse 0.6s ease-in-out;
        }

        @keyframes button-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .success-message {
            background: linear-gradient(45deg, #0F9D58, #0d8a4c);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            opacity: 0;
            animation: slideIn 0.5s ease forwards;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .error-message {
            background: linear-gradient(45deg, #DB4437, #c23321);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
        }

        .processing-spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #ffffff;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 968px) {
            .two-column-container {
                flex-direction: column;
            }
            
            .left-column,
            .right-column {
                flex: 1;
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 10px;
            }
            
            .drop-zone {
                padding: 40px 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <img src="https://media0.giphy.com/media/v1.Y2lkPTZjMDliOTUyZXJqbmc4Z2czempzNzRqY2k4eWFpY3d1NWpzYWF5eTM2Zmkxd2V0ZCZlcD12MV9naWZzX3NlYXJjaCZjdD1n/5NPhdqmyRxn8I/200.gif" alt="Google Logo">
            <div class="logo-text">Googlisator</div>
        </div>
        
        <div class="drop-zone" id="dropZone">
            <h3>Drop metadata.xml here</h3>
            <p>Or click to select file</p>
            <input type="file" class="file-input" id="fileInput" accept=".xml">
        </div>

        <div class="content-preview" id="contentPreview">
            <div class="title-display" id="titleDisplay"></div>
            <div class="package-status">
                <div class="status-text" id="statusText">Package Type Detection waiting...</div>
                <div class="package-type" id="packageType"></div>
            </div>
            <div class="validation-messages" id="validationMessages" style="display: none;"></div>
            
            <!-- Two-column container -->
            <div class="two-column-container">
                <!-- Left Column: Data Preview -->
                <div class="left-column">
                    <div class="data-preview" id="dataPreview" style="display: none;">
                        <h3 class="preview-title">Data Preview & Editing</h3>
                        <div class="preview-table-container">
                            <table class="preview-table" id="previewTable">
                                <thead>
                                    <tr>
                                        <th>Field</th>
                                        <th>Value</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="previewTableBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Asset Analysis -->
                <div class="right-column">
                    <div class="asset-analysis" id="assetAnalysis" style="display: none;">
                        <h3 class="preview-title">Predicted Google Filenames</h3>
                        <div class="asset-count" id="assetCount"></div>
                        <div class="asset-list" id="assetList"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="filename-preview">
            <div class="filename-label">Output Filename:</div>
            <input type="text" class="editable-filename" id="filenameText" value="(Drop a file to preview)">
        </div>

        <div class="processing-spinner" id="processingSpinner"></div>
        <button class="generate-btn" id="generateBtn" disabled>Generate Google Metadata</button>
        
        <div id="messageArea"></div>
    </div>

    <script>
        // All mapping dictionaries from the original Python script
        const clientMapping = {
            'metropolitanfilm': 'CALD',
            'underthemilkyway': 'UTMW',
            'mydigitalcompanysas': 'MDC_J2F',
            'diaphanadistribution': 'Diaphana',
            'pathe': 'Pathe',
            'universcine': 'Universcine',
            'wildsidevideo': 'WildSide'
        };

        const languageMapping = {
            'af': 'Afrikaans', 'ar': 'Arabic', 'bn': 'Bangla / Bengali', 'bg': 'Bulgarian',
            'yue': 'Chinese (Cantonese)', 'yue-Hant': 'Chinese (Cantonese) [Traditional]',
            'ca': 'Catalan', 'hr': 'Croatian', 'cs': 'Czech', 'da': 'Danish',
            'nl': 'Dutch (Netherlands)', 'en': 'English', 'en-AU': 'English (Australia)',
            'en-CA': 'English (Canada)', 'en-FR': 'English (France)', 'en-DE': 'English (Germany)',
            'en-IE': 'English (Ireland)', 'en-NZ': 'English (New Zealand)', 'en-GB': 'English (UK)',
            'en-US': 'English (US)', 'et': 'Estonian', 'fa': 'Persian / Farsi', 'fi': 'Finnish',
            'nl-BE': 'Dutch (Belgium) / Flemish', 'fr': 'French - Continental', 'fr-BE': 'French (Belgium)',
            'fr-CA': 'French (Canadian)', 'fr-FR': 'French (Parisian)', 'fr-CH': 'French (Switzerland)',
            'de': 'German', 'de-AT': 'German (Austria)', 'de-DE': 'German (Germany)',
            'de-CH': 'German (Switzerland)', 'el': 'Greek', 'el-CY': 'Greek (Cyprus)',
            'he': 'Hebrew', 'hi': 'Hindi', 'hu': 'Hungarian', 'is': 'Icelandic',
            'id': 'Indonesian / Bahasa', 'it': 'Italian', 'ja': 'Japanese', 'kn': 'Kannada',
            'kk': 'Kazakh', 'ko': 'Korean', 'lo': 'Lao', 'lv': 'Latvian', 'lt': 'Lithuanian',
            'lb': 'Luxembourgish', 'ms': 'Malay', 'ml': 'Malayalam', 'mt': 'Maltese',
            'cmn-Hans': 'Chinese (Mandarin Simplified)', 'cmn': 'Chinese (Mandarin)',
            'cmn-Hant': 'Chinese (Mandarin Traditional)', 'mr': 'Marathi', 'no': 'Norwegian',
            'pl': 'Polish', 'pt': 'Portuguese', 'pt-BR': 'Portuguese (Brazil)',
            'pt-PT': 'Portuguese (Portugal)', 'pa': 'Punjabi', 'ro': 'Romanian',
            'ru': 'Russian (Russia)', 'sk': 'Slovak', 'sl': 'Slovene/Slovenian',
            'es': 'Spanish', 'es-419': 'Spanish (Latin America)', 'es-MX': 'Spanish (Mexican)',
            'es-ES': 'Spanish (Castilian)', 'sv': 'Swedish', 'tl': 'Tagalog', 'ta': 'Tamil',
            'te': 'Telugu', 'th': 'Thai', 'tr': 'Turkish', 'uk': 'Ukrainian', 'ur': 'Urdu',
            'vi': 'Vietnamese', 'zu': 'Zulu'
        };

        const countryMapping = {
            'AF': 'Afghanistan', 'AL': 'Albania', 'DZ': 'Algeria', 'AS': 'American Samoa',
            'AD': 'Andorra', 'AO': 'Angola', 'AI': 'Anguilla', 'AQ': 'Antarctica',
            'AG': 'Antigua and Barbuda', 'AR': 'Argentina', 'AM': 'Armenia', 'AW': 'Aruba',
            'AU': 'Australia', 'AT': 'Austria', 'AZ': 'Azerbaijan', 'BS': 'Bahamas',
            'BH': 'Bahrain', 'BD': 'Bangladesh', 'BB': 'Barbados', 'BY': 'Belarus',
            'BE': 'Belgium', 'BZ': 'Belize', 'BJ': 'Benin', 'BM': 'Bermuda', 'BT': 'Bhutan',
            'BO': 'Bolivia', 'BQ': 'Bonaire, Sint Eustatius And Saba', 'BA': 'Bosnia and Herzegovina',
            'BW': 'Botswana', 'BV': 'Bouvet Islands', 'BR': 'Brazil', 'IO': 'British Indian Ocean Territory',
            'BN': 'Brunei Darussalam', 'BG': 'Bulgaria', 'BF': 'Burkina-Faso', 'BI': 'Burundi',
            'CV': 'Cape Verde', 'KH': 'Cambodia', 'CM': 'Cameroon', 'CA': 'Canada',
            'KY': 'Cayman Islands', 'CF': 'Central African Republic', 'TD': 'Chad', 'CL': 'Chile',
            'CN': 'China', 'CX': 'Christmas Island', 'CC': 'Coco Islands', 'CO': 'Colombia',
            'KM': 'Comoros', 'CD': 'Congo, The Democratic Republic of the', 'CG': 'Congo',
            'CK': 'Cook Islands', 'CR': 'Costa Rica', 'HR': 'Croatia', 'CU': 'Cuba',
            'CW': 'CuraÃƒÂ§ao', 'CY': 'Cyprus', 'CZ': 'Czech Republic', 'CI': 'Ivory Coast',
            'DK': 'Denmark', 'DJ': 'Djibouti', 'DM': 'Dominica', 'DO': 'Dominican Republic',
            'EC': 'Ecuador', 'EG': 'Egypt', 'SV': 'El Salvador', 'GQ': 'Equatorial Guinea',
            'ER': 'Eritrea', 'EE': 'Estonian', 'SZ': 'Swaziland', 'ET': 'Ethiopia',
            'FK': 'Falkland Islands', 'FO': 'Faroe Islands', 'FJ': 'Fiji', 'FI': 'Finland',
            'FR': 'France', 'GF': 'French Guyana', 'PF': 'French Polynesia', 'TF': 'French Southern Territories',
            'GA': 'Gabon', 'GM': 'Gambia', 'GE': 'Georgia', 'DE': 'Germany', 'GH': 'Ghana',
            'GI': 'Gibraltar', 'GR': 'Greece', 'GL': 'Greenland', 'GD': 'Grenada',
            'GP': 'Guadeloupe', 'GU': 'Guam', 'GT': 'Guatemala', 'GG': 'Guernsey',
            'GN': 'Guinea', 'GW': 'Guinea-Bissau', 'GY': 'Guyana', 'HT': 'Haiti',
            'HM': 'Heard and McDonald Islands', 'VA': 'Vatican City', 'HN': 'Honduras',
            'HK': 'Hong Kong', 'HU': 'Hungary', 'IS': 'Iceland', 'IN': 'India',
            'ID': 'Indonesia', 'IR': 'Iran', 'IQ': 'Iraq', 'IE': 'Ireland',
            'IM': 'Isle Of Man', 'IL': 'Israel', 'IT': 'Italy', 'JM': 'Jamaica',
            'JP': 'Japan', 'JE': 'Jersey', 'JO': 'Jordan', 'KZ': 'Kazakhstan',
            'KE': 'Kenya', 'KI': 'Kiribati', 'KP': 'North Korea', 'KR': 'South Korea',
            'KW': 'Kuwait', 'KG': 'Kyrgyzstan', 'LA': 'Laos', 'LV': 'Latvian',
            'LB': 'Lebanon', 'LS': 'Lesotho', 'LR': 'Liberia', 'LY': 'Libya',
            'LI': 'Liechtenstein', 'LT': 'Lithuanian', 'LU': 'Luxembourg', 'MO': 'Macau',
            'MG': 'Madagascar', 'MW': 'Malawi', 'MY': 'Malaysia', 'MV': 'Maldives',
            'ML': 'Mali', 'MT': 'Malta', 'MH': 'Marshall Islands', 'MQ': 'Martinique',
            'MR': 'Mauritania', 'MU': 'Mauritius', 'YT': 'Mayotte', 'MX': 'Mexico',
            'FM': 'Micronesia', 'MD': 'Moldavia', 'MC': 'Monaco', 'MN': 'Mongolia',
            'ME': 'Montenegro', 'MS': 'Montserrat', 'MA': 'Morocco', 'MZ': 'Mozambique',
            'MM': 'Myanmar', 'NA': 'Namibia', 'NR': 'Nauru', 'NP': 'Nepal',
            'NL': 'Netherlands', 'NC': 'New Caledonia', 'NZ': 'New Zealand', 'NI': 'Nicaragua',
            'NE': 'Niger', 'NG': 'Nigeria', 'NU': 'Niue', 'NF': 'Norfolk Islands',
            'MK': 'Macedonia', 'MP': 'North Mariana Islands', 'NO': 'Norway', 'OM': 'Oman',
            'PK': 'Pakistan', 'PW': 'Palau', 'PS': 'Palestinian Territory, Occupied',
            'PA': 'Panama', 'PG': 'Papua New Guinea', 'PY': 'Paraguay', 'PE': 'Peru',
            'PH': 'Philippines', 'PN': 'Pitcairn Islands', 'PL': 'Poland', 'PT': 'Portugal',
            'PR': 'Puerto Rico', 'QA': 'Qatar', 'RO': 'Romania', 'RU': 'Russian Federation',
            'RW': 'Ruanda', 'RE': 'Reunion', 'BL': 'Saint Barthelemy', 'SH': 'St. Helena',
            'KN': 'St. Kitts and Nevis Anguilla', 'LC': 'St. Lucia', 'MF': 'Saint Martin (French Part)',
            'PM': 'St. Pierre and Miquelon', 'VC': 'St. Vincent and the Grenadines',
            'WS': 'Samoa', 'SM': 'San Marino', 'ST': 'Sao Tome and Principe', 'SA': 'Saudi Arabia',
            'SN': 'Senegal', 'RS': 'Serbia', 'SC': 'Seychelles', 'SL': 'Sierra Leone',
            'SG': 'Singapore', 'SX': 'Sint Maarten (Dutch Part)', 'SK': 'Slovakia',
            'SI': 'Slovenia', 'SB': 'Solomon Islands', 'SO': 'Somalia', 'ZA': 'South Africa',
            'GS': 'South Georgia And The South Sandwich Islands', 'SS': 'South Sudan',
            'ES': 'Spain', 'LK': 'Sri Lanka', 'SD': 'Sudan', 'SR': 'Suriname',
            'SJ': 'Svalbard', 'SE': 'Sweden', 'CH': 'Switzerland', 'SY': 'Syria',
            'TW': 'Taiwan', 'TJ': 'Tajikistan', 'TZ': 'Tanzania', 'TH': 'Thailand',
            'TL': 'Timor-Leste', 'TG': 'Togo', 'TK': 'Tokelau Islands', 'TO': 'Tonga',
            'TT': 'Trinidad and Tobago', 'TN': 'Tunisia', 'TR': 'Turkey', 'TM': 'Turkmenistan',
            'TC': 'Turks and Caicos Islands', 'TV': 'Tuvalu', 'UG': 'Uganda', 'UA': 'Ukraine',
            'AE': 'United Arab Emirates', 'GB': 'United Kingdom', 'UM': 'American Minor Outlying Islands',
            'US': 'USA', 'UY': 'Uruguay', 'UZ': 'Uzbekistan', 'VU': 'Vanuatu',
            'VE': 'Venezuela', 'VN': 'Vietnam', 'VG': 'British Virgin Islands',
            'VI': 'American Virgin Islands', 'WF': 'Wallis and Futuna Islands', 'EH': 'Western Sahara',
            'YE': 'Yemen', 'ZM': 'Zambia', 'ZW': 'Zimbabwe', 'AX': 'Ã…land Islands'
        };

        const genreMapping = {
            'ACTION-ADVENTURE-00': ['Action & Adventure'],
            'AFRICAN-00': ['African Cinema'],
            'ANIME-00': ['Anime', 'Japanese Cinema'],
            'BOLLYWOOD-00': ['Indian Cinema'],
            'CLASSICS-00': ['Classics'],
            'COMEDY-00': ['Comedy'],
            'CONCERT-FILMS-00': ['Music Performance', 'Live Performance'],
            'DOCUMENTARY-00': ['Documentary'],
            'DRAMA-00': ['Drama'],
            'FOREIGN-00': ['World Cinema'],
            'HOLIDAY-00': [],
            'HORROR-00': ['Horror'],
            'INDEPENDENT-00': ['Independent'],
            'KIDS-FAMILY-00': ['Family', "Children's"],
            'MADE-FOR-TV-00': [],
            'MIDDLE-EASTERN-00': [],
            'MUSIC-DOCUMENTARIES-00': ['Music', 'Documentary'],
            'MUSIC-FEATURE-FILMS-00': ['Music'],
            'MUSICALS-00': ['Musical'],
            'REGIONAL-INDIAN-00': ['Indian Cinema'],
            'ROMANCE-00': ['Romance'],
            'RUSSIAN-00': ['World Cinema'],
            'SCIFI-FANTASY-00': ['Science Fiction', 'Fantasy'],
            'SHORT-FILMS-00': ['Short Films'],
            'SPECIAL-INTEREST-00': ['Instructional', 'Education', 'Miscellaneous'],
            'SPORTS-00': ['Sports'],
            'THRILLER-00': ['Thriller', 'Mystery'],
            'TURKISH-00': ['World Cinema'],
            'URBAN-00': [],
            'WESTERN-00': ['Western']
        };

        const ratingMapping = {
            'fr-cnc': {
                'TP': { 'label': 'T', 'description': 'Suitable for all ages' },
                '-10': { 'label': '10', 'description': 'Advised against under 10 years old' },
                '-12': { 'label': '12', 'description': 'Theatrically forbidden to under 12 years old' },
                '-16': { 'label': '16', 'description': 'Theatrically forbidden to under 16 years old' },
                '-18': { 'label': '18', 'description': 'Theatrically forbidden to under 18 years old' },
                'UR': { 'label': 'Sans classification', 'description': 'No Rating Exists' }
            }
        };

        // Global variables
        let xmlFile = null;
        let parsedData = null;
        let validationMessages = [];
        let editableData = {}; // Store edited field values

        // Asset type mapping based on Google delivery requirements (without backdrop and logos)
        const assetTypeMapping = {
            'artwork': {
                assetName: 'PosterArt',
                description: 'Movie Poster Artwork'
            },
            'artwork_16:9': {
                assetName: 'BannerArt16x9', 
                description: '16:9 Banner Artwork'
            }
        };

        const dataFileRoleMapping = {
            'source': {
                assetName: 'Feature',
                description: 'Main Feature Video'
            },
            'audio': {
                assetName: 'Audio',
                description: 'Discrete Audio Track'
            },
            'subtitles': {
                assetName: 'full',
                description: 'Full Subtitles'
            },
            'forced_subtitles': {
                assetName: 'forced',
                description: 'Forced Subtitles'
            },
            'video.end.dub_credits': {
                assetName: 'DubCard',
                description: 'Dub Credits Video'
            }
        };

        function analyzeAssets() {
            if (!parsedData || !parsedData.xmlDoc) {
                console.log('No parsed data or XML document available');
                return [];
            }

            const assets = [];
            const video = parsedData.xmlDoc.querySelector('video');
            if (!video) {
                console.log('No video element found in XML');
                return [];
            }

            const assetsElement = video.querySelector('assets');
            if (!assetsElement) {
                console.log('No assets element found in XML');
                return [];
            }

            // Get basic info for filename generation with safe fallbacks
            const clientPrefix = clientMapping[parsedData.provider] || parsedData.provider || 'UNKNOWN';
            const packageType = parsedData.isMLP ? 'MLP' : '';
            
            // Use edited title if available, otherwise fallback to parsed title
            const displayTitle = editableData['DisplayTitle'] || 
                               (parsedData.studioReleaseTitle || parsedData.title || 'Unknown');
            const normalizedTitle = normalizeTitle(displayTitle);
            
            const org = parsedData.provider === 'metropolitanfilm' ? 
                `NG${parsedData.vendorId}` : (parsedData.vendorId || 'UNKNOWN');

            // Process each asset
            const assetElements = assetsElement.querySelectorAll('asset');
            assetElements.forEach(asset => {
                const assetType = asset.getAttribute('type');
                if (!assetType) return;
                
                // Skip backdrop and logo assets
                if (assetType === 'backdrop_tall' || assetType === 'backdrop_wide' || 
                    assetType === 'single_color_content_logo' || assetType === 'full_color_content_logo') {
                    return;
                }
                
                try {
                    // Handle preview assets (trailers)
                    if (assetType === 'preview') {
                        const territoryEl = asset.querySelector('territory');
                        const territory = territoryEl ? territoryEl.textContent : 'WW';
                        const dataFile = asset.querySelector('data_file[role="source"]');
                        if (dataFile) {
                            const localeEl = dataFile.querySelector('locale');
                            const locale = localeEl ? localeEl.getAttribute('name') : 'en';
                            const localeFormatted = locale === 'en' && territory === 'WW' ? 'en' : locale;
                            const trailerType = territory === 'FR' ? 'Dub_Trailer' : 'Trailer';
                            
                            const filename = generateAssetFilename({
                                clientPrefix, packageType, normalizedTitle, locale: localeFormatted, 
                                assetName: trailerType, org, extension: 'mov'
                            });
                            
                            assets.push({
                                type: `${trailerType} (${territory})`,
                                description: territory === 'FR' ? 'French Dubbed Trailer' : 'International Trailer',
                                filename: filename,
                                locale: localeFormatted
                            });
                        }
                    }
                    
                    // Handle artwork and other asset types
                    else if (assetTypeMapping[assetType]) {
                        const mapping = assetTypeMapping[assetType];
                        const dataFile = asset.querySelector('data_file');
                        const localeEl = dataFile?.querySelector('locale');
                        const locale = localeEl ? localeEl.getAttribute('name') : 'fr-FR';
                        const extension = assetType.includes('artwork') ? 'jpg' : 'png';
                        
                        const filename = generateAssetFilename({
                            clientPrefix, packageType, normalizedTitle, locale, 
                            assetName: mapping.assetName, org, extension
                        });
                        
                        assets.push({
                            type: mapping.assetName,
                            description: mapping.description,
                            filename: filename,
                            locale: locale
                        });
                    }
                    
                    // Handle full asset with data files
                    else if (assetType === 'full') {
                        const dataFiles = asset.querySelectorAll('data_file');
                        dataFiles.forEach(dataFile => {
                            const role = dataFile.getAttribute('role');
                            const mapping = dataFileRoleMapping[role];
                            
                            if (mapping) {
                                const localeEl = dataFile.querySelector('locale');
                                const locale = localeEl ? localeEl.getAttribute('name') : 'en';
                                let extension = 'mov';
                                
                                // Determine file extension based on role
                                if (role === 'subtitles' || role === 'forced_subtitles') {
                                    extension = 'itt';
                                }
                                
                                const filename = generateAssetFilename({
                                    clientPrefix, packageType, normalizedTitle, locale, 
                                    assetName: mapping.assetName, org, extension
                                });
                                
                                assets.push({
                                    type: mapping.assetName,
                                    description: `${mapping.description} (${locale})`,
                                    filename: filename,
                                    locale: locale
                                });
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error processing asset:', error);
                }
            });

            console.log('Analyzed assets:', assets.length);
            return assets;
        }

        function generateAssetFilename({clientPrefix, packageType, normalizedTitle, locale, assetName, org, extension}) {
            const parts = [clientPrefix];
            
            if (packageType) {
                parts.push(packageType);
            }
            
            parts.push(normalizedTitle);
            
            if (locale && locale !== 'generic') {
                parts.push(locale);
            }
            
            if (assetName && assetName !== 'Feature') {
                parts.push(assetName);
            }
            
            parts.push(org);
            
            return `${parts.join('_')}.${extension}`;
        }

        function populateAssetAnalysis() {
            console.log('populateAssetAnalysis called');
            const assets = analyzeAssets();
            console.log('Assets found:', assets);
            
            const assetAnalysis = document.getElementById('assetAnalysis');
            const assetCount = document.getElementById('assetCount');
            const assetList = document.getElementById('assetList');
            
            // Check if elements exist
            if (!assetAnalysis || !assetCount || !assetList) {
                console.error('Asset analysis DOM elements not found');
                return;
            }
            
            if (assets.length === 0) {
                assetCount.textContent = 'No assets detected in XML';
                assetList.innerHTML = '<div style="color: #FFA500; padding: 10px; text-align: center;">No assets found in XML structure</div>';
                return;
            }
            
            assetCount.textContent = `${assets.length} predicted delivery files`;
            assetList.innerHTML = '';
            
            assets.forEach((asset, index) => {
                const assetItem = document.createElement('div');
                assetItem.className = 'asset-item';
                
                assetItem.innerHTML = `
                    <div class="asset-info">
                        <div class="asset-type">${asset.type}</div>
                        <div class="asset-filename">${asset.filename}</div>
                    </div>
                    <button class="copy-btn" onclick="copyToClipboard('${asset.filename}', this)">Copy</button>
                `;
                
                assetList.appendChild(assetItem);
            });
        }

        function copyToClipboard(text, buttonElement) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = buttonElement.textContent;
                buttonElement.textContent = 'Copied!';
                buttonElement.classList.add('copied');
                
                setTimeout(() => {
                    buttonElement.textContent = originalText;
                    buttonElement.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                buttonElement.textContent = 'Copied!';
                buttonElement.classList.add('copied');
                setTimeout(() => {
                    buttonElement.textContent = 'Copy';
                    buttonElement.classList.remove('copied');
                }, 2000);
            });
        }
        
        const fieldConfig = {
            'DisplayTitle': { editable: true, status: 'recommended', label: 'Display Title' },
            'OriginalReleaseTitle': { editable: true, status: 'required', label: 'Original Release Title' },
            'Language': { editable: false, status: 'required', label: 'Language' },
            'Territory': { editable: false, status: 'required', label: 'Territory' },
            'CopyrightYear': { editable: true, status: 'optional', label: 'Copyright Year' },
            'CopyrightLine': { editable: true, status: 'optional', label: 'Copyright Line' },
            'ORG': { editable: false, status: 'recommended', label: 'ORG' },
            'LocalizedSummary_Short': { editable: true, status: 'required', label: 'Synopsis (Short)' },
            'PrimaryGenre': { editable: true, status: 'required', label: 'Primary Genre' },
            'SecondaryGenres': { editable: true, status: 'recommended', label: 'Secondary Genres' },
            'OriginalReleaseDate': { editable: true, status: 'required', label: 'Original Release Date' },
            'CountryOfOrigin': { editable: true, status: 'required', label: 'Country of Origin' },
            'RatingSystem_Rating_Reason': { editable: true, status: 'required', label: 'Rating' },
            'CastDisplayName_CharacterName_Role_BillingOrderNumber': { editable: true, status: 'required', label: 'Cast' },
            'CrewDisplayName_Role_BillingOrderNumber': { editable: true, status: 'recommended', label: 'Crew' }
        };

        // Utility functions
        function normalizeName(name) {
            return name.trim();
        }

        function splitName(name) {
            const parts = name.trim().split(' ');
            if (parts.length === 1) {
                return [parts[0], ''];
            } else if (parts.length === 2) {
                return [parts[0], parts[1]];
            } else if (parts.length >= 3) {
                // Handle name particles (de, da, van, von, del, della, etc.)
                const particles = ['de', 'da', 'van', 'von', 'del', 'della', 'di', 'du', 'le', 'la', 'el'];
                
                // Find the last particle or assume last two words are surname
                let surnameStart = parts.length - 1;
                
                // Check if second-to-last word is a particle
                if (parts.length >= 3) {
                    const secondToLast = parts[parts.length - 2].toLowerCase();
                    if (particles.includes(secondToLast)) {
                        surnameStart = parts.length - 2;
                    }
                }
                
                const firstName = parts.slice(0, surnameStart).join(' ');
                const lastName = parts.slice(surnameStart).join(' ');
                return [firstName, lastName];
            }
            return ['', ''];
        }

        function normalizeTitle(title) {
            return title
                .trim()
                // Remove accents and special characters using proper Unicode normalization
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                // Replace common special characters
                .replace(/['']/g, '')
                .replace(/[""]/g, '')
                .replace(/[&]/g, 'And')
                // Remove punctuation and special characters except spaces and letters/numbers
                .replace(/[^\w\s]/g, '')
                // Split into words, capitalize each, then join without spaces
                .split(/\s+/)
                .filter(word => word.length > 0)
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join('');
        }

        function capitalizeTitle(title) {
            return title.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function showMessage(message, type = 'success') {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            messageArea.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            const file = files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().includes('metadata') || !file.name.endsWith('.xml')) {
                showMessage('Please select a metadata.xml file.', 'error');
                return;
            }

            // Reset state when new file is loaded
            resetEditableData();
            
            xmlFile = file;
            dropZone.innerHTML = `<h3>File: ${file.name}</h3><p>Ready to process</p>`;
            
            // Reset button text
            document.getElementById('generateBtn').textContent = 'Generate Google Metadata';
            
            parseXMLFile(file);
        }

        function resetEditableData() {
            editableData = {};
        }

        function parseXMLFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const xmlText = e.target.result;
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    
                    // Check for parsing errors
                    const parseErrors = xmlDoc.getElementsByTagName('parsererror');
                    if (parseErrors.length > 0) {
                        throw new Error('Invalid XML format');
                    }
                    
                    parseXMLContent(xmlDoc);
                } catch (error) {
                    showMessage(`Failed to parse XML: ${error.message}`, 'error');
                    resetState();
                }
            };
            reader.readAsText(file);
        }

        function parseXMLContent(xmlDoc) {
            try {
                validationMessages = [];
                
                // Get elements with null checks
                const provider = xmlDoc.querySelector('provider');
                if (!provider || !provider.textContent) {
                    throw new Error('Missing or empty <provider> element in XML.');
                }

                const video = xmlDoc.querySelector('video');
                if (!video) {
                    throw new Error('Missing <video> element in XML.');
                }

                const title = video.querySelector('title');
                if (!title || !title.textContent) {
                    throw new Error('Missing or empty <title> element in XML.');
                }

                const studioReleaseTitle = video.querySelector('studio_release_title');
                if (!studioReleaseTitle || !studioReleaseTitle.textContent) {
                    validationMessages.push('<studio_release_title> is missing. fallback to <title>...');
                }

                const language = xmlDoc.querySelector('language');
                if (!language || !language.textContent) {
                    throw new Error('Missing or empty <language> element in XML.');
                }

                const vendorId = video.querySelector('vendor_id');
                if (!vendorId || !vendorId.textContent) {
                    throw new Error('Missing or empty <vendor_id> element in XML.');
                }

                // Store parsed data with safe access
                parsedData = {
                    provider: provider.textContent.trim(),
                    title: title.textContent.trim(),
                    studioReleaseTitle: studioReleaseTitle && studioReleaseTitle.textContent ? studioReleaseTitle.textContent.trim() : null,
                    language: language.textContent.trim(),
                    vendorId: vendorId.textContent.trim(),
                    synopsis: '',
                    theatricalReleaseDate: '',
                    copyrightCline: '',
                    xmlDoc: xmlDoc
                };

                // Safely get optional elements
                const synopsis = video.querySelector('synopsis');
                if (synopsis && synopsis.textContent) {
                    parsedData.synopsis = synopsis.textContent.trim();
                }

                const theatricalReleaseDate = video.querySelector('theatrical_release_date');
                if (theatricalReleaseDate && theatricalReleaseDate.textContent) {
                    parsedData.theatricalReleaseDate = theatricalReleaseDate.textContent.trim();
                }

                const copyrightCline = video.querySelector('copyright_cline');
                if (copyrightCline && copyrightCline.textContent) {
                    parsedData.copyrightCline = copyrightCline.textContent.trim();
                }

                // Determine package type
                const assets = video.querySelector('assets');
                if (!assets) {
                    validationMessages.push('Missing <assets> element in XML. Cannot determine package type (MLP/SLP). Defaulting to SLP.');
                }

                let sourceLocale = null;
                let audioLocale = null;
                
                if (assets) {
                    const fullAsset = assets.querySelector('asset[type="full"]');
                    if (fullAsset) {
                        const sourceFile = fullAsset.querySelector('data_file[role="source"]');
                        const audioFile = fullAsset.querySelector('data_file[role="audio"]');
                        
                        if (sourceFile) {
                            const locale = sourceFile.querySelector('locale');
                            sourceLocale = locale?.getAttribute('name');
                        }
                        
                        if (audioFile) {
                            const locale = audioFile.querySelector('locale');
                            audioLocale = locale?.getAttribute('name');
                        }
                    }
                }

                parsedData.isMLP = sourceLocale && audioLocale && sourceLocale !== audioLocale;

                updateUI();
                
            } catch (error) {
                console.error('XML parsing error details:', error);
                showMessage(`Failed to parse XML: ${error.message}`, 'error');
                resetState();
            }
        }

        function updateUI() {
            if (!parsedData) return;

            // Show content preview
            document.getElementById('contentPreview').style.display = 'block';

            // Update title display
            const displayTitle = parsedData.studioReleaseTitle || parsedData.title;
            document.getElementById('titleDisplay').textContent = capitalizeTitle(displayTitle);

            // Update package status
            document.getElementById('statusText').textContent = 'Package Type Detected';
            document.getElementById('statusText').style.color = '#0F9D58';
            document.getElementById('packageType').textContent = parsedData.isMLP ? 'MLP' : 'SLP';

            // Update validation messages
            const validationEl = document.getElementById('validationMessages');
            if (validationMessages.length > 0) {
                validationEl.textContent = validationMessages.join('\n');
                validationEl.style.display = 'block';
            } else {
                validationEl.style.display = 'none';
            }

            // Update filename preview
            updateFilenamePreview();

            // Populate data preview table
            populatePreviewTable();

            // Populate asset analysis
            populateAssetAnalysis();

            // Show both sections
            document.getElementById('dataPreview').style.display = 'block';
            document.getElementById('assetAnalysis').style.display = 'block';

            // Enable generate button
            document.getElementById('generateBtn').disabled = false;
        }

        function populatePreviewTable() {
            const previewData = generateMetadataRow();
            const tbody = document.getElementById('previewTableBody');
            tbody.innerHTML = '';

            // Initialize editable data with current values if not already set
            Object.keys(fieldConfig).forEach(fieldKey => {
                if (editableData[fieldKey] === undefined && previewData.hasOwnProperty(fieldKey)) {
                    editableData[fieldKey] = previewData[fieldKey] || '';
                }
            });

            Object.keys(fieldConfig).forEach(fieldKey => {
                if (!previewData.hasOwnProperty(fieldKey)) return;

                const config = fieldConfig[fieldKey];
                const value = editableData[fieldKey] || previewData[fieldKey] || '';
                
                const row = document.createElement('tr');
                
                // Field name cell
                const nameCell = document.createElement('td');
                nameCell.className = 'field-name';
                nameCell.textContent = config.label;
                
                // Field value cell
                const valueCell = document.createElement('td');
                valueCell.className = 'field-value';
                
                if (config.editable) {
                    const input = document.createElement('textarea');
                    input.className = 'editable-field';
                    input.value = value;
                    
                    // Set different heights for different field types
                    if (fieldKey === 'LocalizedSummary_Short') {
                        input.rows = 3;
                        input.style.minHeight = '60px';
                    } else if (fieldKey === 'CastDisplayName_CharacterName_Role_BillingOrderNumber' || 
                               fieldKey === 'CrewDisplayName_Role_BillingOrderNumber') {
                        input.rows = 4;
                        input.style.minHeight = '80px';
                    } else {
                        input.rows = value.length > 50 ? 2 : 1;
                        input.style.minHeight = '20px';
                    }
                    
                    input.addEventListener('input', (e) => {
                        editableData[fieldKey] = e.target.value;
                        if (fieldKey === 'DisplayTitle') {
                            updateFilenamePreview(); // Update filename when title changes
                            populateAssetAnalysis(); // Update asset filenames when title changes
                        }
                    });
                    valueCell.appendChild(input);
                } else {
                    valueCell.textContent = value;
                    valueCell.style.color = '#cccccc';
                }
                
                // Status cell
                const statusCell = document.createElement('td');
                statusCell.className = 'field-status';
                const statusSpan = document.createElement('span');
                statusSpan.className = `status-${config.status}`;
                statusSpan.textContent = config.status.toUpperCase();
                statusCell.appendChild(statusSpan);
                
                row.appendChild(nameCell);
                row.appendChild(valueCell);
                row.appendChild(statusCell);
                tbody.appendChild(row);
            });
        }

        function updateFilenamePreview() {
            if (!parsedData) return;

            const clientPrefix = clientMapping[parsedData.provider] || parsedData.provider;
            const packageType = parsedData.isMLP ? 'MLP' : '';
            
            // Use edited title if available, otherwise fallback to parsed title
            const displayTitle = editableData['DisplayTitle'] || 
                                (parsedData.studioReleaseTitle || parsedData.title);
            const normalizedTitle = normalizeTitle(displayTitle);
            
            const org = parsedData.provider === 'metropolitanfilm' ? 
                `NG${parsedData.vendorId}` : parsedData.vendorId;

            let filename;
            if (packageType) {
                filename = `${clientPrefix}_${packageType}_${normalizedTitle}_${parsedData.language}_Metadata_${org}.xlsx`;
            } else {
                filename = `${clientPrefix}_${normalizedTitle}_${parsedData.language}_Metadata_${org}.xlsx`;
            }

            const filenameEl = document.getElementById('filenameText');
            
            // Only update if it's not currently being edited by the user
            if (document.activeElement !== filenameEl) {
                filenameEl.value = filename;
            }
            
            parsedData.outputFilename = filenameEl.value; // Use current value in the field
            
            // Add event listener to filename field if not already added
            if (!filenameEl.hasEventListener) {
                filenameEl.addEventListener('input', (e) => {
                    parsedData.outputFilename = e.target.value;
                });
                filenameEl.hasEventListener = true;
            }
        }

        function resetState() {
            xmlFile = null;
            parsedData = null;
            validationMessages = [];
            editableData = {}; // Clear edited data
            
            dropZone.innerHTML = '<h3>Drop metadata.xml here</h3><p>Or click to select file</p>';
            document.getElementById('contentPreview').style.display = 'none';
            document.getElementById('dataPreview').style.display = 'none';
            document.getElementById('assetAnalysis').style.display = 'none';
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('generateBtn').textContent = 'Generate Google Metadata';
            
            const filenameEl = document.getElementById('filenameText');
            filenameEl.value = '(Drop a file to preview)';
            filenameEl.hasEventListener = false; // Reset event listener flag
            
            document.getElementById('statusText').textContent = 'Package Type Detection waiting...';
            document.getElementById('statusText').style.color = '#ffffff';
            document.getElementById('packageType').textContent = '';
        }

        function createConfetti() {
            const generateBtn = document.getElementById('generateBtn');
            const buttonRect = generateBtn.getBoundingClientRect();
            
            // Calculate button center position
            const buttonCenterX = buttonRect.left + buttonRect.width / 2;
            const buttonCenterY = buttonRect.top + buttonRect.height / 2;

            const confettiContainer = document.createElement('div');
            confettiContainer.className = 'confetti-container';
            document.body.appendChild(confettiContainer);

            // Create 100 confetti pieces (doubled from original)
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Position confetti at button center
                confetti.style.left = buttonCenterX + 'px';
                confetti.style.top = buttonCenterY + 'px';
                
                // Random explosion direction and distance
                const angle = (Math.PI * 2 * i) / 100 + (Math.random() - 0.5) * 1; // Spread evenly with some randomness
                const velocity = Math.random() * 300 + 150; // 150-450px distance
                const dx = Math.cos(angle) * velocity;
                const dy = Math.sin(angle) * velocity - Math.random() * 200; // Bias upward
                
                // Set custom properties for animation
                confetti.style.setProperty('--dx', dx + 'px');
                confetti.style.setProperty('--dy', dy + 'px');
                confetti.style.setProperty('--rotation', (Math.random() * 720 - 360) + 'deg');
                
                // Random delay for staggered explosion
                confetti.style.animationDelay = Math.random() * 0.3 + 's';
                
                // Random duration
                confetti.style.animationDuration = (Math.random() * 1 + 1.5) + 's'; // 1.5-2.5s
                
                // Random size variation
                const size = Math.random() * 6 + 8; // 8-14px
                confetti.style.width = size + 'px';
                confetti.style.height = size + 'px';
                
                // Random shape - some square, some circular
                if (Math.random() > 0.5) {
                    confetti.style.borderRadius = '50%';
                }
                
                confettiContainer.appendChild(confetti);
            }

            // Remove confetti container after animation
            setTimeout(() => {
                if (confettiContainer.parentNode) {
                    confettiContainer.parentNode.removeChild(confettiContainer);
                }
            }, 4000);
        }

        // Excel generation
        document.getElementById('generateBtn').addEventListener('click', () => {
            // Add celebrating class for button animation
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.classList.add('celebrating');
            
            // Trigger confetti
            createConfetti();
            
            // Remove celebrating class after animation
            setTimeout(() => {
                generateBtn.classList.remove('celebrating');
            }, 600);
            
            // Call the actual generate function
            generateExcel();
        });

        function generateExcel() {
            if (!parsedData) {
                showMessage('Please drop a valid metadata.xml file.', 'error');
                return;
            }

            try {
                document.getElementById('processingSpinner').style.display = 'block';
                document.getElementById('generateBtn').disabled = true;

                // Use edited data if available, otherwise use original data
                const data = { ...generateMetadataRow() };
                Object.keys(editableData).forEach(key => {
                    if (editableData[key] !== undefined) {
                        data[key] = editableData[key];
                    }
                });
                
                const headerRow = generateHeaderRow();
                const possibleValuesData = generatePossibleValuesData();

                // Create workbook
                const wb = XLSX.utils.book_new();
                
                // Create SampleUploadData sheet with proper data structure
                const sheetData = [
                    Object.keys(data), // Column headers
                    Object.values(headerRow), // Description row
                    Object.values(data) // Data row
                ];
                
                const ws1 = XLSX.utils.aoa_to_sheet(sheetData);
                
                // Apply formatting to SampleUploadData sheet
                formatSampleSheet(ws1, Object.keys(data).length);
                
                // Create Possible_Values sheet
                const ws2 = XLSX.utils.json_to_sheet(possibleValuesData);
                
                // Apply formatting to Possible_Values sheet
                formatPossibleValuesSheet(ws2, possibleValuesData);

                XLSX.utils.book_append_sheet(wb, ws1, 'SampleUploadData');
                XLSX.utils.book_append_sheet(wb, ws2, 'Possible_Values');

                // Generate and download file
                XLSX.writeFile(wb, parsedData.outputFilename);

                document.getElementById('processingSpinner').style.display = 'none';
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('generateBtn').textContent = 'Generate Google Metadata ✓';
                showMessage('Excel file generated and downloaded successfully!');

            } catch (error) {
                document.getElementById('processingSpinner').style.display = 'none';
                document.getElementById('generateBtn').disabled = false;
                showMessage(`Failed to generate Excel file: ${error.message}`, 'error');
            }
        }

        function formatSampleSheet(ws, numColumns) {
            // Set column widths (31 characters ≈ 215 pixels)
            const columnWidth = 31;
            ws['!cols'] = [];
            for (let i = 0; i < numColumns; i++) {
                ws['!cols'].push({ width: columnWidth });
            }

            // Apply formatting to all cells
            const range = XLSX.utils.decode_range(ws['!ref']);
            
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    const cell = ws[cellAddress];
                    
                    if (!cell) continue;

                    // Initialize cell style object
                    if (!cell.s) cell.s = {};

                    // Add borders to all cells
                    cell.s.border = {
                        top: { style: 'thin', color: { rgb: '000000' } },
                        bottom: { style: 'thin', color: { rgb: '000000' } },
                        left: { style: 'thin', color: { rgb: '000000' } },
                        right: { style: 'thin', color: { rgb: '000000' } }
                    };

                    // Apply light orange background to header description row (row 1, 0-indexed)
                    if (row === 1) {
                        cell.s.fill = {
                            fgColor: { rgb: 'FFE4B5' }
                        };
                        cell.s.alignment = {
                            wrapText: true,
                            vertical: 'top'
                        };
                    }
                }
            }
        }

        function formatPossibleValuesSheet(ws, data) {
            // Set appropriate column widths for this sheet
            const possibleValuesColumnWidths = [25, 25, 25, 25, 20, 20, 25, 20];
            ws['!cols'] = [];
            for (let i = 0; i < possibleValuesColumnWidths.length; i++) {
                ws['!cols'].push({ width: possibleValuesColumnWidths[i] });
            }

            // Set row heights
            ws['!rows'] = [];
            ws['!rows'][0] = { hpt: 25 }; // Header row height

            // Apply formatting using correct SheetJS syntax
            const range = XLSX.utils.decode_range(ws['!ref']);
            
            for (let row = range.s.r; row <= range.e.r; row++) {
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                    if (!ws[cellAddress]) continue;
                    
                    const cell = ws[cellAddress];
                    
                    // Initialize style object
                    cell.s = cell.s || {};

                    // Apply borders to all cells
                    cell.s.border = {
                        top: { style: 'thin' },
                        bottom: { style: 'thin' },
                        left: { style: 'thin' },
                        right: { style: 'thin' }
                    };

                    // Header row formatting
                    if (row === 0) {
                        cell.s.patternType = 'solid';
                        cell.s.fgColor = { rgb: '366092' }; // Dark blue
                        cell.s.font = { 
                            bold: true,
                            color: { rgb: 'FFFFFF' },
                            sz: 11 
                        };
                        cell.s.alignment = { 
                            horizontal: 'center',
                            vertical: 'center'
                        };
                    }
                    // Data rows
                    else {
                        cell.s.font = { 
                            sz: 10,
                            color: { rgb: '000000' }
                        };
                        cell.s.alignment = { 
                            horizontal: 'left',
                            vertical: 'center'
                        };
                        
                        // White background for odd rows, light gray for even rows
                        if (row % 2 === 1) {
                            cell.s.patternType = 'solid';
                            cell.s.fgColor = { rgb: 'FFFFFF' }; // White
                        } else {
                            cell.s.patternType = 'solid';
                            cell.s.fgColor = { rgb: 'F8F9FA' }; // Light gray
                        }
                    }
                }
            }
        }

        function generateMetadataRow() {
            const xmlDoc = parsedData.xmlDoc;
            const video = xmlDoc.querySelector('video');
            
            const theatricalReleaseDate = parsedData.theatricalReleaseDate;
            const copyrightYear = theatricalReleaseDate ? theatricalReleaseDate.split('-')[0] : '';
            
            const originalReleaseTitle = parsedData.studioReleaseTitle || parsedData.title;
            const org = parsedData.provider === 'metropolitanfilm' ? 
                `NG${parsedData.vendorId}` : parsedData.vendorId;

            const data = {
                'TitleLevel': 'Feature',
                'TitleMgmtID': '',
                'Language': languageMapping[parsedData.language] || parsedData.language,
                'Territory': 'France',
                'Season Number': '',
                'DisplayTitle': capitalizeTitle(parsedData.title),
                'DisplayTitle_Territory': '',
                'OriginalReleaseTitle': capitalizeTitle(originalReleaseTitle),
                'CopyrightYear': copyrightYear,
                'CopyrightLine': parsedData.copyrightCline,
                'ORG': org,
                'OriginalSummary_Short': '',
                'LocalizedSummary_Short': parsedData.synopsis,
                'LocalizedSummary_Medium': '',
                'LocalizedSummary_Long': '',
                'LocalizedSummary_Territory': '',
                'PrimaryGenre': '',
                'SecondaryGenres': '',
                'SequenceNumber': '',
                'OriginalReleaseDate': theatricalReleaseDate,
                'LocalizedReleaseDate_Type': '',
                'RatingSystem_Rating_Reason': '',
                'CountryOfOrigin': '',
                'CastDisplayName_CharacterName_Role_BillingOrderNumber': '',
                'CrewDisplayName_Role_BillingOrderNumber': ''
            };

            // Process country of origin
            const primaryCountry = video.querySelector('countries_of_origin country[primary="true"]') ||
                                 video.querySelector('country');
            if (primaryCountry) {
                data['CountryOfOrigin'] = countryMapping[primaryCountry.textContent] || primaryCountry.textContent;
            }

            // Process genres
            const genres = [];
            const genreElements = video.querySelectorAll('genres genre');
            genreElements.forEach(genre => {
                const genreCode = genre.getAttribute('code');
                const mappedGenres = genreMapping[genreCode] || [];
                if (mappedGenres.length > 0) {
                    genres.push(...mappedGenres);
                } else if (genre.textContent) {
                    genres.push(genre.textContent);
                }
            });

            if (genres.length > 0) {
                data['PrimaryGenre'] = genres[0];
                data['SecondaryGenres'] = genres.slice(1).join(';');
            }

            // Process ratings
            const frRating = video.querySelector('ratings rating[system="fr-cnc"]');
            if (frRating) {
                const ratingCode = frRating.getAttribute('code');
                const ratingLabel = ratingMapping['fr-cnc'][ratingCode]?.label || 'Sans classification';
                data['RatingSystem_Rating_Reason'] = `CNC|${ratingLabel}`;
            }

            // Process regional release date
            const frRegion = video.querySelector('regions region');
            if (frRegion) {
                const territory = frRegion.querySelector('territory');
                if (territory && territory.textContent === 'FR') {
                    const releaseDate = frRegion.querySelector('theatrical_release_date');
                    if (releaseDate) {
                        data['LocalizedReleaseDate_Type'] = `${releaseDate.textContent}|Theatrical`;
                    }
                }
            }

            // Process cast
            const castList = [];
            let billingOrder = 1;
            const castMembers = video.querySelectorAll('cast cast_member');
            castMembers.forEach(member => {
                const displayName = member.querySelector('display_name');
                const characterName = member.querySelector('characters character character_name') ||
                                   member.querySelector('character_name');
                
                if (displayName && characterName) {
                    const [firstName, lastName] = splitName(normalizeName(displayName.textContent));
                    const character = characterName.textContent || '';
                    castList.push(`${firstName}|${lastName}|${character}|Actor|${billingOrder}`);
                    billingOrder++;
                }
            });
            data['CastDisplayName_CharacterName_Role_BillingOrderNumber'] = castList.join(';');

            // Process crew
            const crewList = [];
            billingOrder = 1;
            const crewMembers = video.querySelectorAll('crew crew_member');
            crewMembers.forEach(member => {
                const displayName = member.querySelector('display_name');
                const role = member.querySelector('roles role');
                
                if (displayName && role) {
                    const [firstName, lastName] = splitName(normalizeName(displayName.textContent));
                    crewList.push(`${firstName}|${lastName}|${role.textContent}|${billingOrder}`);
                    billingOrder++;
                }
            });
            data['CrewDisplayName_Role_BillingOrderNumber'] = crewList.join(';');

            return data;
        }

        function generateHeaderRow() {
            return {
                'TitleLevel': 'REQUIRED - Indicates Title Level/Hierarchy of Row',
                'TitleMgmtID': 'DO NOT USE',
                'Language': 'REQUIRED - Indicates Language Value of Specific, Translated Fields',
                'Territory': 'REQUIRED - Indicates Territory Value of Specific Fields',
                'Season Number': 'REQUIRED - for Title Level Episode - Used for grouping individual episodes into the proper season. Please include with every episode.',
                'DisplayTitle': 'RECOMMENDED - Corresponds with Language value for displaying a translated title. Can be the same as Original Title',
                'DisplayTitle_Territory': 'Optional - A territory value in this column indicates your DisplayTitle is specific ONLY for the given territory value in this column in addition to what language it is (Column \'Language\'). Leave this field empty if you only need a generic display title for a given language.',
                'OriginalReleaseTitle': 'REQUIRED - Is the original title that the content was released under when first distributed. Display Title can be the same value as OriginalReleaseTitle.',
                'CopyrightYear': 'Optional',
                'CopyrightLine': 'Optional',
                'ORG': 'RECOMMENDED - The ORG value is an optional, recommended generic ID that is created by the content owner and is specific to that rows TitleLevel (Show, Season, Episode, or Feature).',
                'OriginalSummary_Short': 'RECOMMENDED - Is the original short synopsis that the content was released with when first distributed. Is assumed to match the original spoken language of the title.',
                'LocalizedSummary_Short': 'REQUIRED - Is a short synopsis that has been translated to the language of the metadata.',
                'LocalizedSummary_Medium': 'Is a Medium synopsis that has been translated to the language of the metadata.',
                'LocalizedSummary_Long': 'Is a Long synopsis that has been translated to the language of the metadata.',
                'LocalizedSummary_Territory': 'Optional - A territory value in this column indicates your Localized Summary being specific ONLY for the given territory value in this column in addition to what language it is (Column \'Language\'). Leave this field empty if you only need a generic summary for a given language.',
                'PrimaryGenre': 'REQUIRED - the default classification value of your content. It can be supplemented in the secondary genres column.\n\nPlease see the Possible Values sheet for a list of valid genres.',
                'SecondaryGenres': 'RECOMMENDED - optional values to provide secondary classification of your content. Is semicolon delimited.\n\nPlease see the Possible Values sheet for a list of valid genres.',
                'SequenceNumber': 'REQUIRED - a whole number that details the position of the content.',
                'OriginalReleaseDate': 'REQUIRED - Year-Month-Day that the content was originally released. Formatting is YYYY-MM-DD (2018-01-01)',
                'LocalizedReleaseDate_Type': 'REQUIRED - Is the Year-Month-Day|Release Type that the content was made available in a given territory. Please see the Possible Values tab for a full list of Types',
                'RatingSystem_Rating_Reason': 'REQUIRED - The rating system and value that are valid for the territory specified. Can include a rating reason.\n\nRatings are validated based on the latest MovieLabs Rating Spec',
                'CountryOfOrigin': 'REQUIRED - Is the country that the content was primary produced in.',
                'CastDisplayName_CharacterName_Role_BillingOrderNumber': 'REQUIRED - Is Cast/Voice talent of of your content. Will be localized based on Language in row. Must be formatted with pipe-delimiters as \nFirstName MiddleName|LastName|CharacterName|TalentType|BillingOrder \nwith each member separated by a semicolon. If data not exist for the respective section please still include the same amount of pipe-delimiters.',
                'CrewDisplayName_Role_BillingOrderNumber': 'RECOMMENDED - Is Crew contributor(s) of your content. Will be localized based on Language in row.\nMust be formatted with pipe-delimiters as \nFirstName MiddleName|LastName|CapacityType|BillingOrder \nwith each member separated by a semicolon. If data does not exist for the respective section please still include the same amount of pipe-delimiters.'
            };
        }

        function generatePossibleValuesData() {
            const validLanguageValues = Object.values(languageMapping);
            const validTerritoryValues = Object.values(countryMapping);
            const validMovieGenres = [
                'Action', 'Action & Adventure', 'Adolescence', 'Adult', 'Adventure', 'African Cinema',
                'Animation', 'Anime', 'Australiana', "Children's", 'Classics', 'Comedy', 'Crime',
                'Documentary', 'Drama', 'Education', 'Erotic', 'Faith and Spirituality', 'Family',
                'Fantasy', 'Food', 'Horror', 'Independent', 'Indian Cinema', 'Instructional',
                'Japanese Cinema', 'LGBT', 'Live Performance', 'Miscellaneous', 'Music',
                'Music Performance', 'Musical', 'Mystery', 'Mystery & Suspense', 'Period Drama (Samurai)',
                'Reality', 'Romance', 'Science Fiction', 'Short Films', 'Sports', 'Thriller',
                'Variety/Talk Show', 'Variety & Talk Show', 'War', 'Western', 'World Cinema'
            ];
            const validSeriesGenres = [
                'Action', 'Action & Adventure', 'Adult', 'Adventure', 'Animation', 'Anime',
                'Beauty & Fashion', "Children's", 'Classic TV', 'Comedy', 'Documentary', 'Drama',
                'Education', 'Entertainment', 'Erotic', 'Faith and Spirituality', 'Family', 'Fantasy',
                'Food', 'Gaming', 'Horror', 'Health & Fitness', 'Home & Garden', 'Independent',
                'Instructional', 'Learning & Education', 'Nature', 'News', 'Live Performance',
                'Miscellaneous', 'Music Performance', 'Musical', 'Mystery', 'Reality',
                'Reality & Game Shows', 'Romance', 'Science & Tech', 'Science Fiction', 'Soaps',
                'Sports', 'Thriller', 'Variety/Talk Show', 'Western', 'Travel'
            ];
            const validCastTalent = ['Actor', 'Voice', 'Narrator', 'Guest Star'];
            const validCrewCapacity = ['Director', 'Producer', 'Writer', 'Screenwriter'];
            const validReleaseDateTypes = [
                'original', 'Broadcast', 'DVD', 'Blu-Ray', 'Hospitality', 'PayTV', 'InternetBuy',
                'InternetRent', 'Theatrical', 'VOD', 'SVOD'
            ];
            const validTitleLevelTypes = ['Feature', 'Season', 'Series', 'Episode'];

            const maxRows = Math.max(
                validLanguageValues.length, validTerritoryValues.length, validMovieGenres.length,
                validSeriesGenres.length, validCastTalent.length, validCrewCapacity.length,
                validReleaseDateTypes.length, validTitleLevelTypes.length
            );

            const possibleValuesData = [];
            for (let i = 0; i < maxRows; i++) {
                possibleValuesData.push({
                    'Valid Language Values': validLanguageValues[i] || '',
                    'Valid Territory Values': validTerritoryValues[i] || '',
                    'Valid Movie/Feature Genres': validMovieGenres[i] || '',
                    'Valid Series Genres': validSeriesGenres[i] || '',
                    'Talent/Capacity - Cast': validCastTalent[i] || '',
                    'Talent/Capacity - Crew': validCrewCapacity[i] || '',
                    'Localized Release Date Types': validReleaseDateTypes[i] || '',
                    'TitleLevel Types': validTitleLevelTypes[i] || ''
                });
            }

            return possibleValuesData;
        }
    </script>
</body>
</html>